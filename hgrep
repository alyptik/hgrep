#!/bin/perl -s

use strict;
use warnings;
use File::Grep qw( fgrep fmap fdo );
use File::Find ();
# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.
# for the convenience of &wanted calls, including -eval statements:
use vars qw( *name *dir *prune );
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

sub wanted;

my (@files, $color, $context, $idx, $num);
my ($flag, $version) = (0, v0.2.0);
# Setup color escapes with tput
my ($highlight, $reset) = (`tput bold && tput setaf 9`, `tput sgr0`);
my @query = @ARGV;
my $usage = "
Usage: hgrep -h -i -r -v -c=\"(y|n)\" -C=\"#\" -n=\"#\" <query>
  -h --help:	Print help
  -i:		Case-insensitive matching (works both with and without -r)
  -r:		Parse query as a regular expression
  -v --version:	Show version
  -c=\"(y|n)\":	Colorize output (default: enabled)
  -C=\"#\":	Number of after-context lines (default: 1)
  -n=\"#\":	Number of matches to print (default: 10)
";

# Parse command line switches
{
	no strict;
	no warnings;

	print "$usage\n" if ($h || ${-help});
	printf "hgrep v%vd\n", $version if ($v || ${-version});
	exit if ($h || $v || ${-help} || ${-version});

	map { $_ = quotemeta $_ } @query if !$r;
	map { $_ = qr/$_/ } @query if ($r && !$i);
	map { $_ = qr/$_/i } @query if $i;

	$num = $n // 10;
	$num = 10 if ($num =~ m/[^0-9]/ || $num < 0);

	$color = $c // 1;
	$color = 0 if $color =~ m/^(?:0|no?|false|never)$/i;

	$context = $idx = $C // 1;
	$context = $idx = 1 if ($context =~ m/[^0-9]/ || $context < 0);
}

print "\n"."Searching for: \"".join("\" \"", @query)."\"\n";
print "# of matches that will be printed: $num\n";
print "# of after-context lines that will be printed: $context\n\n";

# Traverse desired filesystems
File::Find::find({wanted => \&wanted}, '/usr/include');
exit;

sub wanted {
	my ($dev, $ino, $mode, $nlink, $uid, $gid);
	(($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
		-f _ && /^.*\.h\z/s &&
		# TODO: Add before-context line handling
		map {
			my $cur = $_;
			fdo {
				if (m/$cur/ || $flag) {
					# Add color if switch is set
					s/($cur)/$highlight$1$reset/g if $color;
					print if (m/$cur/ || ($flag && $context > 0));
					# Don't count blank lines toward context
					$idx-- unless m/^$/;
					if ($flag && $idx < 1) {
						$num--;
						$idx = $context;
						$flag = 0;
					} elsif (!$flag) {
						$idx = $context;
						$flag = 1;
					}
				}
				# Quit after specified # of matches reached
				exit if ($num < 1);
			} $name;
		} @query;
}

